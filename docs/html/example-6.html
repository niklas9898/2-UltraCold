<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UltraCold: example-6</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UltraCold
   </div>
   <div id="projectbrief">Collection of C++ libraries for the study of ultra-cold systems in the context of Gross-Pitaevskii theory</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example-6.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">example-6 </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Title-6">Far from equilibrium dynamics in a 2D dipolar Bose gas, using GPU acceleration.</a><ul><li class="level2"><a href="#Introduction-6">Introduction</a></li>
<li class="level2"><a href="#What-6">Program description</a></li>
<li class="level2"><a href="#Results-6">Results</a></li>
<li class="level2"><a href="#Uncommented-6">The plain program</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Santo Maria Roccuzzo (<a href="#" onclick="location.href='mai'+'lto:'+'san'+'to'+'m.r'+'oc'+'cuz'+'zo'+'@gm'+'ai'+'l.c'+'om'; return false;">santo<span class="obfuscator">.nosp@m.</span>m.ro<span class="obfuscator">.nosp@m.</span>ccuzz<span class="obfuscator">.nosp@m.</span>o@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a>)</dd></dl>
<h1><a class="anchor" id="Title-6"></a>
Far from equilibrium dynamics in a 2D dipolar Bose gas, using GPU acceleration.</h1>
<h2><a class="anchor" id="Introduction-6"></a>
Introduction</h2>
<p >We want to study the far from equilibrium behavior of a 2D dipolar Bose gas. A mean field model for the system can be obtained by starting from the Gross-Pitaevskii equation from a 3D dipolar system</p>
<p class="formulaDsp">
\[
\begin{equation}
    i\hbar\frac{\partial }{\partial t}\Psi({\bf r},t) =
     \left[-\frac{\hbar^2}{2m}\nabla^2+V_{\mathrm{ext}}({\bf r})+g|\Psi({\bf r},t)|^2+ \right.
     \left. \frac{\mu_0\mu^2}{4\pi} \int d{\bf r}&#39; U_{dd}({\bf r}-{\bf r}&#39;) |\Psi({\bf r}&#39;,t)|^2 \right] \Psi({\bf r},t)
\end{equation}
\]
</p>
<p >and assuming that the system is confined along one direction via a strong harmonic potential. Choosing the z-axis as the confinement axis, the wave function can be factorized as</p>
<p class="formulaDsp">
\[
\begin{equation}
    \Psi({\bf r},t) = \phi_0(z)\psi(\boldsymbol{\rho},t)
\end{equation}
\]
</p>
<p> where \(\phi_0(z)\) is the ground state of the harmonic oscillator along the z-axis, and \(\psi({\boldsymbol{\rho}},t)\) is the wave function of the condensate, depending on the transverse coordinate \(\boldsymbol{\rho}\). Plugging this ansatz into the GPE and integrating out the z direction, one finds an effective two-dimensional Gross-Pitaevskii equation</p>
<p class="formulaDsp">
\[
\begin{equation}
        i\hbar\frac{\partial}{\partial t} \psi(\boldsymbol{\rho},t) =
        \left[-\frac{\hbar^2}{2m}\nabla_{\boldsymbol{\rho}}^2+\frac{g}{\sqrt{2\pi}l_z}|\psi(\boldsymbol{\rho},t)|^2+
        \Phi_{dd}(\boldsymbol{\rho},t) \right] \psi(\boldsymbol{\rho},t)
\end{equation}
\]
</p>
<p >Here, we have introduced the effective planar dipolar potential</p>
<p class="formulaDsp">
\[
\begin{equation}
    \Phi_{dd}(\boldsymbol{\rho},t) = \int U_{dd}^{2D}(\boldsymbol{\rho}-\boldsymbol{\rho}&#39;)|\psi(\boldsymbol{\rho},t)|^2
\end{equation}
\]
</p>
<p >The analytic form of \(U_{dd}^{2D}\) in real space is not easy to calculate or to interpret. Instead, in Fourier space it assumes a simpler form</p>
<p class="formulaDsp">
\[
\begin{equation}
    \tilde{U}_{dd}^{2D}({\bf k}_{\boldsymbol{\rho}}) = \frac{4\pi\mu_0\mu^2}{9\sqrt{2\pi}l_z}
    [F_\parallel(\tilde{\bf q})\sin^2(\alpha)+F_\perp(\tilde{\bf q})\cos^2(\alpha)]
\end{equation}
\]
</p>
<p >with</p>
<p class="formulaDsp">
\[
\begin{align}
    &amp; F_\parallel(\tilde{\bf q}) = -1+3\sqrt{\pi}\frac{\tilde{q}_x^2}{\tilde{q}^2}\mathrm{e}^{\tilde{q}^2}\mathrm{erfc}({\tilde{q})} \nonumber \\
    &amp; F_\perp(\tilde{\bf q})= 2-3\sqrt{\pi}\tilde{q}^2\mathrm{e}^{\tilde{q}^2}\mathrm{erfc}({\tilde{q})}
\end{align}
\]
</p>
<p >and \(\tilde{\bf q} = \frac{{\bf k}l_z}{\sqrt{2}}\), \(\alpha\) being the tilting angle between the direction of polarization of the dipoles and the z-axis.</p>
<p >In the absence of transverse trapping, the chemical potential of a quasi-two-dimensional homogeneous dipolar condensate is given by</p>
<p class="formulaDsp">
\[
\begin{equation}
    \mu = \frac{g}{\sqrt{2\pi}l_z}n\left[1+\epsilon_{dd}(3\cos^2\alpha-1)\right]
\end{equation}
\]
</p>
<p >For any value of the tilting angle $\alpha$, the chemical potential becomes negative for \(\epsilon_{dd}&gt;\frac{1}{3\cos^2\alpha-1}\), causing a phonon instability leading to the collapse of the gas.</p>
<h2><a class="anchor" id="What-6"></a>
Program description</h2>
<p >The input file for this example will be called <code>example-6.prm</code> and contains the following text</p>
<pre class="fragment"># Mesh parameters

xmax = 40 # Size of the mesh along the x-axis, in micrometers. The mesh will extend from -xmax to xmax
ymax = 40 # Size of the mesh along the y-axis, in micrometers. The mesh will extend from -ymax to ymax

nx = 1024 # Number of points along the x-axis
ny = 1024 # Number of points along the y-axis

omegaz = 1000

# Physical parameters

scattering length   = 90.0  # Scattering length in units of the Bohr radius
dipolar    length   = 132.0  # Dipolar length in units of the Bohr radius
number of particles = 1000000  # Total number of atoms
atomic mass         = 164    # Atomic mass, in atomic mass units
theta = 1.05 # tilt angle in radiant

# Run parameters for gradient descent

number of gradient descent steps = 200 # maximum number of gradient descent steps
residual                         = 1.E-12 # Threshold on the norm of the residual
alpha                            = 1.E-3 # gradient descent step
beta                             = 0.9   # step for the heavy-ball acceleration method

# Run parameters for real-time dynamics

number of real time steps = 50000000 # Total number of time-steps for real time dynamics
time step                 = 0.001   # Time step for real-time dynamics, in milliseconds
write output every = 10000

# Initial conditions

box initial conditions = false
vortex lattice initial conditions = false
vortex random distribution initial conditions = true
winding number = 1
number of imprinted defects = 1000</pre><p >At the beginning of the program, we define our solver class with customizable output</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Our solver class, with customizable real-time output</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_dipoles2d.html">Dipoles2d</a> : <span class="keyword">public</span> <a class="code hl_class" href="class_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver.html">cudaSolvers::DipolarGPSolver</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>DipolarGPSolver::DipolarGPSolver;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                         std::ostream&amp; output_stream) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">MKLWrappers::DFtCalculator</a> ft_output_calculator;</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; ft_wave_function;</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> nbar_x;</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> nbar_y;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">Dipoles2d::write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                                std::ostream &amp;output_stream)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(iteration_number == 0)</div>
<div class="line">    {</div>
<div class="line">        ft_wave_function.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#ab815d29b1c62bf50c666e52766e78c6a">reinit</a>(nx,ny);</div>
<div class="line">        nbar_x.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#ab815d29b1c62bf50c666e52766e78c6a">reinit</a>(nx);</div>
<div class="line">        nbar_y.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#ab815d29b1c62bf50c666e52766e78c6a">reinit</a>(ny);</div>
<div class="line">        ft_output_calculator.reinit(wave_function_output,ft_wave_function);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>(iteration_number % write_output_every == 0)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="class_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver.html#a3675cd2005345c02f42cfe21d29913d6">copy_out_wave_function</a>();</div>
<div class="line">        <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a> psi_out;</div>
<div class="line">        psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;psi&quot;</span>+std::to_string(iteration_number/write_output_every));</div>
<div class="line">        psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x_axis,y_axis,wave_function_output,<span class="stringliteral">&quot;psi&quot;</span>,<span class="stringliteral">&quot;BINARY&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Calculate momentum distribution</span></div>
<div class="line">        ft_output_calculator.compute_forward();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reset nx and ny</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) nbar_x(i) = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; ny; ++i) nbar_y(i) = 0.0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Calculate averages along x and y</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            {</div>
<div class="line">                nbar_x(i) += std::pow(std::abs(ft_wave_function(i,j)),2);</div>
<div class="line">                nbar_y(j) += std::pow(std::abs(ft_wave_function(i,j)),2);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        std::ofstream momentum_cuts;</div>
<div class="line">        momentum_cuts.open(<span class="stringliteral">&quot;nkx&quot;</span>+std::to_string(iteration_number/write_output_every)+<span class="stringliteral">&quot;.txt&quot;</span>,std::ios::out);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> ix = 0; ix &lt; <a class="code hl_class" href="classint.html">int</a>(nx/2+1); ++ix)</div>
<div class="line">            momentum_cuts &lt;&lt; kx_axis(ix) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                          &lt;&lt; nbar_x(ix)</div>
<div class="line">                          &lt;&lt; std::endl;</div>
<div class="line">        momentum_cuts.close();</div>
<div class="line"> </div>
<div class="line">        momentum_cuts.open(<span class="stringliteral">&quot;nky&quot;</span>+std::to_string(iteration_number/write_output_every)+<span class="stringliteral">&quot;.txt&quot;</span>,std::ios::out);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> iy = 0; iy &lt; <a class="code hl_class" href="classint.html">int</a>(ny/2+1); ++iy)</div>
<div class="line">            momentum_cuts &lt;&lt; ky_axis(iy) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                          &lt;&lt; nbar_y(iy)</div>
<div class="line">                          &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_dipoles2d_html"><div class="ttname"><a href="class_dipoles2d.html">Dipoles2d</a></div><div class="ttdef"><b>Definition:</b> example-5.cpp:30</div></div>
<div class="ttc" id="aclass_dipoles2d_html_a7a3362455056efb1e51dc2caad00fdaa"><div class="ttname"><a href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">Dipoles2d::write_operator_splitting_output</a></div><div class="ttdeci">void write_operator_splitting_output(size_t iteration_number, std::ostream &amp;output_stream) override</div><div class="ttdoc">Operator splitting output.</div><div class="ttdef"><b>Definition:</b> example-5.cpp:40</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">UltraCold::GraphicOutput::DataWriter</a></div><div class="ttdoc">A class to output a data Vector in real space.</div><div class="ttdef"><b>Definition:</b> DataWriter.hpp:71</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_a5379ac7b98c084855b372e863c095856"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">UltraCold::GraphicOutput::DataWriter::set_output_name</a></div><div class="ttdeci">void set_output_name(const std::string &amp;output_file_name)</div><div class="ttdoc">Set the name for the output data file, input as an std::string.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:31</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_aec73552d1a4ccd5f3111c6268961279b"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">UltraCold::GraphicOutput::DataWriter::write_vtk</a></div><div class="ttdeci">void write_vtk(Vector&lt; double &gt; &amp;x_axis, Vector&lt; double &gt; &amp;y_axis, Vector&lt; double &gt; &amp;real_output_vector, const char *vector_name, const char *format)</div><div class="ttdoc">Write an output data file in .vtk format, for real 2D output.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:805</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator_html"><div class="ttname"><a href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">UltraCold::MKLWrappers::DFtCalculator</a></div><div class="ttdoc">Class to calculate Fourier transforms using Intel's MKL DFT functions.</div><div class="ttdef"><b>Definition:</b> DFtCalculator.hpp:60</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html">UltraCold::Vector</a></div><div class="ttdoc">A class that represents arrays of numerical elements.</div><div class="ttdef"><b>Definition:</b> Vector.hpp:49</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html_ab815d29b1c62bf50c666e52766e78c6a"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html#ab815d29b1c62bf50c666e52766e78c6a">UltraCold::Vector::reinit</a></div><div class="ttdeci">void reinit(int)</div><div class="ttdoc">Reinitialize a one-dimensional Vector.</div><div class="ttdef"><b>Definition:</b> Vector.cpp:202</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver.html">UltraCold::cudaSolvers::DipolarGPSolver</a></div><div class="ttdoc">GPU-accelerated solver for a dipolar Gross-Pitaevskii equation.</div><div class="ttdef"><b>Definition:</b> cudaDipolarGPSolver.cuh:43</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver_html_a3675cd2005345c02f42cfe21d29913d6"><div class="ttname"><a href="class_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver.html#a3675cd2005345c02f42cfe21d29913d6">UltraCold::cudaSolvers::DipolarGPSolver::copy_out_wave_function</a></div><div class="ttdeci">void copy_out_wave_function()</div><div class="ttdoc">Copy the wave function out from device to host.</div><div class="ttdef"><b>Definition:</b> cudaDipolarGPSolver.cu:758</div></div>
<div class="ttc" id="aclassint_html"><div class="ttname"><a href="classint.html">int</a></div></div>
<div class="ttc" id="anamespace_ultra_cold_html"><div class="ttname"><a href="namespace_ultra_cold.html">UltraCold</a></div><div class="ttdoc">All the classes and functions necessary to work with UltraCold.</div><div class="ttdef"><b>Definition:</b> BogolyubovSolver.cpp:25</div></div>
</div><!-- fragment --><p >Notice that, in the overridden function for the real time output, we have a call to the function</p>
<div class="fragment"><div class="line">copy_out_wave_function();</div>
</div><!-- fragment --><p >When invoked, this function makes a copy of the current wave function stored in the GPU memory into an array, accessible from the host, called <em>wave_function_output</em>, that we use to calculate and output the integrated momentum distributions.</p>
<p >Skipping the usual part on the reading of input parameters, setting the units, and creating the mesh, we jump to the more interesting part, i.e. the choice of initial conditions.</p>
<p >If, in the input file, we have</p>
<pre class="fragment">box initial conditions = true
</pre><p >the initial condition for the dynamics will be a "box" in momentum space, i.e. the initial wave function will be characterized by a high occupancy of modes up to a certain cut-off in momentum space. Additionally, each mode will have a random phase, so that in the end the initial condition will realize an extremely far from equilibrium situation. This is achieved in the following piece of code</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(box_initial_conditions)</div>
<div class="line"> {</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">     clock::time_point beginning = clock::now();</div>
<div class="line">     clock::duration d = clock::now() - beginning;</div>
<div class="line">     generator.seed(d.count());</div>
<div class="line"> </div>
<div class="line">     std::uniform_real_distribution&lt;double&gt; phase_distribution(0,TWOPI);</div>
<div class="line"> </div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">         {</div>
<div class="line">             <span class="keywordtype">double</span> random_phase = phase_distribution(generator);</div>
<div class="line">             <span class="keywordflow">if</span> (std::abs(kx(i)) &lt;= 0.1 / (TWOPI*healing_length) &amp;&amp; std::abs(ky(j)) &lt;= 0.1 /(TWOPI*healing_length))</div>
<div class="line">                 psitilde(i, j) = exp(-ci * random_phase);</div>
<div class="line">         }</div>
<div class="line"> </div>
<div class="line">     <a class="code hl_class" href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">MKLWrappers::DFtCalculator</a> dft(psi,psitilde);</div>
<div class="line">     dft.compute_backward();</div>
<div class="line"> </div>
<div class="line">     <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">     norm *= dv;</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line"> }</div>
</div><!-- fragment --><p >If, instead, in the input file we have</p>
<pre class="fragment">vortex lattice initial conditions = true
</pre><p >then the initial condition will be a regular lattice of defects, whose number is specified by</p>
<pre class="fragment">number of imprinted defects = 10
</pre><p >Notice that, in this case, the lattice will contain 10x10 defects, so be careful in not exaggerating. Each imprinted defect will have a winding number specified by</p>
<pre class="fragment">winding number = 6
</pre><p >Actually, the lattice will contain alternating sign defects, so that, for example, with the choice of the parameters described in the last lines, you will have 10 lines of 10 defects, each containing a vortex with a winding number of 6, an anti-vortex with a winding number of -6, and so on. The piece of code that realizes all of that is the following one</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(vortex_lattice_initial_conditions)</div>
<div class="line"> {</div>
<div class="line">     <span class="keywordtype">double</span> sqrt_density = std::sqrt(number_of_particles/(4*xmax*ymax));</div>
<div class="line"> </div>
<div class="line">     <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x_defect_positions(number_of_imprinted_defects);</div>
<div class="line">     <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y_defect_positions(number_of_imprinted_defects);</div>
<div class="line"> </div>
<div class="line">     std::uniform_real_distribution&lt;double&gt; x_displacement(-2*dx,2*dx);</div>
<div class="line">     std::uniform_real_distribution&lt;double&gt; y_displacement(-2*dy,2*dy);</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">     clock::time_point beginning = clock::now();</div>
<div class="line">     clock::duration d = clock::now() - beginning;</div>
<div class="line">     generator.seed(d.count());</div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_imprinted_defects; ++i)</div>
<div class="line">         x_defect_positions(i) = -xmax+dx+i*nx/number_of_imprinted_defects*dx;</div>
<div class="line"> </div>
<div class="line">     beginning = clock::now();</div>
<div class="line">     d = clock::now() - beginning;</div>
<div class="line">     generator.seed(d.count());</div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_imprinted_defects; ++i)</div>
<div class="line">         y_defect_positions(i) = -ymax+dy+i*ny/number_of_imprinted_defects*dy;</div>
<div class="line"> </div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">         {</div>
<div class="line">             psi(i,j) = sqrt_density;</div>
<div class="line"> </div>
<div class="line">             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i_defect=0; i_defect &lt; number_of_imprinted_defects; ++i_defect)</div>
<div class="line">                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j_defect=0; j_defect &lt; number_of_imprinted_defects; ++j_defect)</div>
<div class="line">                 {</div>
<div class="line">                     <span class="keywordtype">double</span> phase = atan2(y(j)-y_defect_positions(j_defect)+y_displacement(generator),</div>
<div class="line">                                          x(i)-x_defect_positions(i_defect)+x_displacement(generator));</div>
<div class="line">                     phase *= (i_defect%2 == 0 &amp;&amp; j_defect%2 == 0 ||</div>
<div class="line">                               i_defect%2 != 0 &amp;&amp; j_defect%2 != 0) ? winding_number : -winding_number;</div>
<div class="line">                     psi(i,j) *= exp(ci*phase);</div>
<div class="line">                 }</div>
<div class="line">         }</div>
<div class="line"> </div>
<div class="line">     <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">     norm *= dv;</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> }</div>
</div><!-- fragment --><p >Next, if in the input file we have</p>
<pre class="fragment">vortex random distribution initial conditions = true
</pre><p >the initial condition will simply be a random distribution of vortices and anti-vortices, with a number specified by</p>
<pre class="fragment">number of imprinted defects = 1000
</pre><p >Notice here that there will be, with this choice, 500 vortices and 500 anti-vortices. The piece of code that does that is the following</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(vortex_random_distribution_initial_conditions)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> sqrt_density = std::sqrt(number_of_particles/(4*xmax*ymax));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x_defect_positions(number_of_imprinted_defects);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y_defect_positions(number_of_imprinted_defects);</div>
<div class="line"> </div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; x_defect_distribution(-xmax,xmax);</div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; y_defect_distribution(-ymax,ymax);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">    clock::time_point beginning = clock::now();</div>
<div class="line">    clock::duration d = clock::now() - beginning;</div>
<div class="line">    generator.seed(d.count());</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_imprinted_defects; ++i) x_defect_positions(i) = x_defect_distribution(generator);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">    beginning = clock::now();</div>
<div class="line">    d = clock::now() - beginning;</div>
<div class="line">    generator.seed(d.count());</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_imprinted_defects; ++i) y_defect_positions(i) = y_defect_distribution(generator);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">        {</div>
<div class="line">            psi(i,j) = sqrt_density;</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i_defect=0; i_defect &lt; number_of_imprinted_defects; ++i_defect)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> phase = atan2(y(j)-y_defect_positions(i_defect),x(i)-x_defect_positions(i_defect));</div>
<div class="line">                phase *= (i_defect%2==0) ? winding_number : -winding_number;</div>
<div class="line">                psi(i,j) *= exp(ci*phase);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= dv;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p >Be sure that only one (or none) of these options is true. If more then one option is true, the different initial conditions will just be applied sequentially on a uniform initial wave function, with consequences difficult to predict. Finally, if none of these options is true, the initial wave function will just be a uniform one plus some noise on top</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> sqrt_density = std::sqrt(number_of_particles/(4*xmax*ymax));</div>
<div class="line"> </div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; random_distribution(0,1);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">    clock::time_point beginning = clock::now();</div>
<div class="line">    clock::duration d = clock::now() - beginning;</div>
<div class="line">    generator.seed(d.count());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            psi(i,j) = (1.0+random_distribution(generator))*sqrt_density;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= dv;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p >Once the initial wave function is set, we can define our solver class</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_dipoles2d.html">Dipoles2d</a> gp_solver(x,y,psi,Vext,scattering_length,dipolar_length,theta);</div>
</div><!-- fragment --><p >If the initial conditions are either the vortex lattice or the random distribution of defects, the above code only writes the correct phase pattern, but not the density pattern. In order to have our vortex lattice or random distribution of vortices, we need to take a few step in imaginary time. This is achieved in the following piece of code</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(vortex_lattice_initial_conditions || vortex_random_distribution_initial_conditions)</div>
<div class="line">{</div>
<div class="line">    std::fstream gradient_descent_output_stream;</div>
<div class="line">    gradient_descent_output_stream.open(<span class="stringliteral">&quot;gradient_descent_output.csv&quot;</span>,std::ios::out);</div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                      alpha,</div>
<div class="line">                                                                      beta,</div>
<div class="line">                                                                      std::cout,</div>
<div class="line">                                                                      1);</div>
<div class="line"> </div>
<div class="line">    gradient_descent_output_stream.close();</div>
<div class="line">    gp_solver.reinit(Vext,psi);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p >Finally, we add some Truncated Wigner noise on top of this initial wave function and run the simulation in real time</p>
<div class="fragment"><div class="line">    gp_solver.set_tw_initial_conditions(<span class="keyword">false</span>);</div>
<div class="line">    gp_solver.run_operator_splitting(number_of_real_time_steps,time_step,std::cout,write_output_every);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Results-6"></a>
Results</h2>
<p >Starting for example from an initial random distribution of defects, we obtain an interesting dynamics characterized by the clustering of equal-sign defects and a slow process of annihilation of opposite sign defects. Screenshots of the typical density profile in 2d at different times of the dynamics are the following</p>
<div class="image">
<img src="example-6-densities.png" alt=""/>
</div>
<p >while typical screenshots of vortex clustering, including streamlines of the superfluid velocity field, are the following</p>
<div class="image">
<img src="example-6-clusters.png" alt="" width="800px"/>
</div>
<p >while this is how momentum distributions look like before and after rescaling</p>
<div class="image">
<img src="example-6-momenta.png" alt="" width="800px"/>
</div>
<p >We extract the scaling exponents</p>
<p class="formulaDsp">
\[

\begin{align}
&amp; \alpha_x = 0.18 \pm 0.05, \quad \beta_x = 0.20 \pm 0.02 \nonumber \\
&amp; \alpha_y = 0.19 \pm 0.06, \quad \beta_y = 0.21 \pm 0.02
\end{align}

\]
</p>
<p >which are isotropic in space and compatible with those found for a non-dipolar system.</p>
<h2><a class="anchor" id="Uncommented-6"></a>
The plain program</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Our solver class, with customizable real-time output</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_dipoles2d.html">Dipoles2d</a> : <span class="keyword">public</span> <a class="code hl_class" href="class_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver.html">cudaSolvers::DipolarGPSolver</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>DipolarGPSolver::DipolarGPSolver;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                         std::ostream&amp; output_stream) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">MKLWrappers::DFtCalculator</a> ft_output_calculator;</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; ft_wave_function;</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> nbar_x;</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> nbar_y;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">Dipoles2d::write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                                std::ostream &amp;output_stream)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(iteration_number == 0)</div>
<div class="line">    {</div>
<div class="line">        ft_wave_function.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#ab815d29b1c62bf50c666e52766e78c6a">reinit</a>(nx,ny);</div>
<div class="line">        nbar_x.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#ab815d29b1c62bf50c666e52766e78c6a">reinit</a>(nx);</div>
<div class="line">        nbar_y.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#ab815d29b1c62bf50c666e52766e78c6a">reinit</a>(ny);</div>
<div class="line">        ft_output_calculator.reinit(wave_function_output,ft_wave_function);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>(iteration_number % write_output_every == 0)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="class_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver.html#a3675cd2005345c02f42cfe21d29913d6">copy_out_wave_function</a>();</div>
<div class="line">        <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a> psi_out;</div>
<div class="line">        psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;psi&quot;</span>+std::to_string(iteration_number/write_output_every));</div>
<div class="line">        psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x_axis,y_axis,wave_function_output,<span class="stringliteral">&quot;psi&quot;</span>,<span class="stringliteral">&quot;BINARY&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Calculate momentum distribution</span></div>
<div class="line">        ft_output_calculator.compute_forward();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reset nx and ny</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) nbar_x(i) = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; ny; ++i) nbar_y(i) = 0.0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Calculate averages along x and y</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            {</div>
<div class="line">                nbar_x(i) += std::pow(std::abs(ft_wave_function(i,j)),2);</div>
<div class="line">                nbar_y(j) += std::pow(std::abs(ft_wave_function(i,j)),2);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        std::ofstream momentum_cuts;</div>
<div class="line">        momentum_cuts.open(<span class="stringliteral">&quot;nkx&quot;</span>+std::to_string(iteration_number/write_output_every)+<span class="stringliteral">&quot;.txt&quot;</span>,std::ios::out);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> ix = 0; ix &lt; <a class="code hl_class" href="classint.html">int</a>(nx/2+1); ++ix)</div>
<div class="line">            momentum_cuts &lt;&lt; kx_axis(ix) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                          &lt;&lt; nbar_x(ix)</div>
<div class="line">                          &lt;&lt; std::endl;</div>
<div class="line">        momentum_cuts.close();</div>
<div class="line"> </div>
<div class="line">        momentum_cuts.open(<span class="stringliteral">&quot;nky&quot;</span>+std::to_string(iteration_number/write_output_every)+<span class="stringliteral">&quot;.txt&quot;</span>,std::ios::out);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> iy = 0; iy &lt; <a class="code hl_class" href="classint.html">int</a>(ny/2+1); ++iy)</div>
<div class="line">            momentum_cuts &lt;&lt; ky_axis(iy) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                          &lt;&lt; nbar_y(iy)</div>
<div class="line">                          &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read input parameters from file &quot;dipolars2d.prm&quot;. This must be placed in the same directory as</span></div>
<div class="line">    <span class="comment">// the executable</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-6.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length    = ip.retrieve_double(<span class="stringliteral">&quot;dipolar length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> theta = ip.retrieve_double(<span class="stringliteral">&quot;theta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_real_time_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of real time steps&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> time_step                       = ip.retrieve_double(<span class="stringliteral">&quot;time step&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> write_output_every=ip.retrieve_int(<span class="stringliteral">&quot;write output every&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> box_initial_conditions = ip.retrieve_bool(<span class="stringliteral">&quot;box initial conditions&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> vortex_lattice_initial_conditions = ip.retrieve_bool(<span class="stringliteral">&quot;vortex lattice initial conditions&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> vortex_random_distribution_initial_conditions =</div>
<div class="line">            ip.retrieve_bool(<span class="stringliteral">&quot;vortex random distribution initial conditions&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> winding_number = ip.retrieve_int(<span class="stringliteral">&quot;winding number&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_imprinted_defects = ip.retrieve_int(<span class="stringliteral">&quot;number of imprinted defects&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// These two constants are for fixing the units</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5; <span class="comment">// hbar in amu*mum^2/s</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;    <span class="comment">// bohr radius in mum</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Lengths are measured in units of the harmonic oscillator length along the z-axis, times as 1/(2 PI omega_z)</span></div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line">    time_step     = time_step*omegaz/1000.0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*(omegaz)));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length    *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the mesh</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y(ny);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dx = 2.*xmax/nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2.*ymax/ny;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) x(i) = -xmax + i*dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ny; ++i) y(i) = -ymax + i*dy;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dv = dx*dy;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the momentum mesh</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> kx(nx),ky(ny);</div>
<div class="line">    <a class="code hl_function" href="namespace_ultra_cold.html#a49073b90537d0b230deb60941ed6f0b4">create_mesh_in_Fourier_space</a>(x,y,kx,ky);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize wave function and external potential</span></div>
<div class="line">    <span class="comment">// Wave function is initialized in momentum space populating</span></div>
<div class="line">    <span class="comment">// low momentum modes each with a random phase</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    <span class="keywordtype">double</span> density = number_of_particles/(4*xmax*ymax);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx,ny),psitilde(nx,ny);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx,ny);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print out some useful parameters</span></div>
<div class="line">    <span class="keywordtype">double</span> epsilon_dd=dipolar_length/scattering_length;</div>
<div class="line">    <span class="keywordtype">double</span> expected_chemical_potential = sqrt(8*PI)*(scattering_length)*density*(1+epsilon_dd*(3*pow(cos(theta),2)-1));</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;density = &quot;</span> &lt;&lt; number_of_particles/(4*xmax*ymax*pow(a_ho,2)) &lt;&lt; <span class="stringliteral">&quot; mum^{-2}&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;expected chemical potential   = &quot;</span> &lt;&lt; expected_chemical_potential &lt;&lt; <span class="stringliteral">&quot; hbar omegaz&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordtype">double</span> healing_length = 1./sqrt(std::abs(expected_chemical_potential));</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;az= &quot;</span> &lt;&lt; a_ho &lt;&lt; <span class="stringliteral">&quot; mum&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;healing_length    = &quot;</span> &lt;&lt; healing_length*a_ho &lt;&lt; <span class="stringliteral">&quot; mum&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;mesh size along x = &quot;</span> &lt;&lt; 2*xmax*a_ho &lt;&lt; <span class="stringliteral">&quot; mum&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;mesh size along y = &quot;</span> &lt;&lt; 2*ymax*a_ho &lt;&lt; <span class="stringliteral">&quot; mum&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;step size along x = &quot;</span> &lt;&lt; dx*a_ho &lt;&lt; <span class="stringliteral">&quot; mum&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;step size along y = &quot;</span> &lt;&lt; dy*a_ho &lt;&lt; <span class="stringliteral">&quot; mum&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;natural time step = &quot;</span> &lt;&lt; 1./(expected_chemical_potential * omegaz/1000) &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;kxi = &quot;</span> &lt;&lt; 1./healing_length &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;dipolar factor = &quot;</span> &lt;&lt; (1+epsilon_dd*(3*pow(cos(theta),2)-1)) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;kxi nodipo = &quot;</span> &lt;&lt; sqrt((1+epsilon_dd*(3*pow(cos(theta),2)-1))) * 1./healing_length &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;kmax= &quot;</span> &lt;&lt; 1./(2*dx) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::default_random_engine generator;</div>
<div class="line"> </div>
<div class="line">    std::complex&lt;double&gt; ci={0.0,1.0};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(box_initial_conditions)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">        clock::time_point beginning = clock::now();</div>
<div class="line">        clock::duration d = clock::now() - beginning;</div>
<div class="line">        generator.seed(d.count());</div>
<div class="line"> </div>
<div class="line">        std::uniform_real_distribution&lt;double&gt; phase_distribution(0,TWOPI);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> random_phase = phase_distribution(generator);</div>
<div class="line">                <span class="keywordflow">if</span> (std::abs(kx(i)) &lt;= 0.1 / (TWOPI*healing_length) &amp;&amp; std::abs(ky(j)) &lt;= 0.1 /(TWOPI*healing_length))</div>
<div class="line">                    psitilde(i, j) = exp(-ci * random_phase);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">MKLWrappers::DFtCalculator</a> dft(psi,psitilde);</div>
<div class="line">        dft.compute_backward();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">        norm *= dv;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(vortex_lattice_initial_conditions)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">double</span> sqrt_density = std::sqrt(number_of_particles/(4*xmax*ymax));</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x_defect_positions(number_of_imprinted_defects);</div>
<div class="line">        <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y_defect_positions(number_of_imprinted_defects);</div>
<div class="line"> </div>
<div class="line">        std::uniform_real_distribution&lt;double&gt; x_displacement(-2*dx,2*dx);</div>
<div class="line">        std::uniform_real_distribution&lt;double&gt; y_displacement(-2*dy,2*dy);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">        clock::time_point beginning = clock::now();</div>
<div class="line">        clock::duration d = clock::now() - beginning;</div>
<div class="line">        generator.seed(d.count());</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_imprinted_defects; ++i)</div>
<div class="line">            x_defect_positions(i) = -xmax+dx+i*nx/number_of_imprinted_defects*dx;</div>
<div class="line"> </div>
<div class="line">        beginning = clock::now();</div>
<div class="line">        d = clock::now() - beginning;</div>
<div class="line">        generator.seed(d.count());</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_imprinted_defects; ++i)</div>
<div class="line">            y_defect_positions(i) = -ymax+dy+i*ny/number_of_imprinted_defects*dy;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            {</div>
<div class="line">                psi(i,j) = sqrt_density;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i_defect=0; i_defect &lt; number_of_imprinted_defects; ++i_defect)</div>
<div class="line">                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j_defect=0; j_defect &lt; number_of_imprinted_defects; ++j_defect)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keywordtype">double</span> phase = atan2(y(j)-y_defect_positions(j_defect)+y_displacement(generator),</div>
<div class="line">                                             x(i)-x_defect_positions(i_defect)+x_displacement(generator));</div>
<div class="line">                        phase *= (i_defect%2 == 0 &amp;&amp; j_defect%2 == 0 ||</div>
<div class="line">                                  i_defect%2 != 0 &amp;&amp; j_defect%2 != 0) ? winding_number : -winding_number;</div>
<div class="line">                        psi(i,j) *= exp(ci*phase);</div>
<div class="line">                    }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">        norm *= dv;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(vortex_random_distribution_initial_conditions)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> sqrt_density = std::sqrt(number_of_particles/(4*xmax*ymax));</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x_defect_positions(number_of_imprinted_defects);</div>
<div class="line">        <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y_defect_positions(number_of_imprinted_defects);</div>
<div class="line"> </div>
<div class="line">        std::uniform_real_distribution&lt;double&gt; x_defect_distribution(-xmax,xmax);</div>
<div class="line">        std::uniform_real_distribution&lt;double&gt; y_defect_distribution(-ymax,ymax);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">        clock::time_point beginning = clock::now();</div>
<div class="line">        clock::duration d = clock::now() - beginning;</div>
<div class="line">        generator.seed(d.count());</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_imprinted_defects; ++i) x_defect_positions(i) = x_defect_distribution(generator);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">        beginning = clock::now();</div>
<div class="line">        d = clock::now() - beginning;</div>
<div class="line">        generator.seed(d.count());</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; number_of_imprinted_defects; ++i) y_defect_positions(i) = y_defect_distribution(generator);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            {</div>
<div class="line">                psi(i,j) = sqrt_density;</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i_defect=0; i_defect &lt; number_of_imprinted_defects; ++i_defect)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordtype">double</span> phase = atan2(y(j)-y_defect_positions(i_defect),x(i)-x_defect_positions(i_defect));</div>
<div class="line">                    phase *= (i_defect%2==0) ? winding_number : -winding_number;</div>
<div class="line">                    psi(i,j) *= exp(ci*phase);</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">        norm *= dv;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> sqrt_density = std::sqrt(number_of_particles/(4*xmax*ymax));</div>
<div class="line"> </div>
<div class="line">        std::uniform_real_distribution&lt;double&gt; random_distribution(0,1);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock;</div>
<div class="line">        clock::time_point beginning = clock::now();</div>
<div class="line">        clock::duration d = clock::now() - beginning;</div>
<div class="line">        generator.seed(d.count());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">                psi(i,j) = (1.0+random_distribution(generator))*sqrt_density;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">        norm *= dv;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Write the initial wave function in a .vtk file</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a> data_out;</div>
<div class="line">    data_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;initial_wave_function_gradient_descent&quot;</span>);</div>
<div class="line">    data_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,psi,<span class="stringliteral">&quot;psi&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize the solver</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    <a class="code hl_class" href="class_dipoles2d.html">Dipoles2d</a> gp_solver(x,y,psi,Vext,scattering_length,dipolar_length,theta);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The output from the short imaginary time propagation will be written in the</span></div>
<div class="line">    <span class="comment">// file &quot;gradient_descent_output.csv&quot;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    <span class="keywordflow">if</span>(vortex_lattice_initial_conditions || vortex_random_distribution_initial_conditions)</div>
<div class="line">    {</div>
<div class="line">        std::fstream gradient_descent_output_stream;</div>
<div class="line">        gradient_descent_output_stream.open(<span class="stringliteral">&quot;gradient_descent_output.csv&quot;</span>,std::ios::out);</div>
<div class="line">        <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">        std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                          alpha,</div>
<div class="line">                                                                          beta,</div>
<div class="line">                                                                          std::cout,</div>
<div class="line">                                                                          1);</div>
<div class="line"> </div>
<div class="line">        gradient_descent_output_stream.close();</div>
<div class="line">        gp_solver.reinit(Vext,psi);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Run the real time simulation!</span></div>
<div class="line">    <span class="comment">// The output will be written to the shell</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    gp_solver.set_tw_initial_conditions(<span class="keyword">false</span>);</div>
<div class="line">    gp_solver.run_operator_splitting(number_of_real_time_steps,time_step,std::cout,write_output_every);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclass_ultra_cold_1_1_tools_1_1_input_parser_html"><div class="ttname"><a href="class_ultra_cold_1_1_tools_1_1_input_parser.html">UltraCold::Tools::InputParser</a></div><div class="ttdoc">Class to read input parameters from files.</div><div class="ttdef"><b>Definition:</b> InputParser.hpp:93</div></div>
<div class="ttc" id="anamespace_ultra_cold_html_a49073b90537d0b230deb60941ed6f0b4"><div class="ttname"><a href="namespace_ultra_cold.html#a49073b90537d0b230deb60941ed6f0b4">UltraCold::create_mesh_in_Fourier_space</a></div><div class="ttdeci">void create_mesh_in_Fourier_space(Vector&lt; double &gt; &amp;x, Vector&lt; double &gt; &amp;kx)</div><div class="ttdoc">Creation of a mesh in Fourier space for a one-dimensional problem.</div><div class="ttdef"><b>Definition:</b> mesh_fourier_space.cpp:31</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
